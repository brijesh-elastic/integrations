config_version: 2
interval: {{interval}}
resource.tracer:
  enabled: {{enable_request_tracer}}
  filename: "../../logs/cel/http-request-trace-*.ndjson"
  maxbackups: 5
{{#if proxy_url}}
resource.proxy_url: {{proxy_url}}
{{/if}}
{{#if ssl}}
resource.ssl: {{ssl}}
{{/if}}
{{#if http_client_timeout}}
resource.timeout: {{http_client_timeout}}
{{/if}}
{{#if max_executions}}
max_executions: {{max_executions}}
{{/if}}
resource.url: {{url}}
state:
  batch_size: {{batch_size}}
  api_token: {{api_token}}
  stage: {{stage}}
redact:
  fields:
    - api_token
program: |
  (
    has(state.worklist) && size(state.worklist.data) > 0 ?
      {
        "worklist": state.worklist,
        "index": state.index
      }
    :
      request("GET",
        state.url.trim_right("/") + "/secure/vulnerability/v1/" + state.stage + "-results?" + {
          "limit": [string(state.batch_size)],
          ?"cursor": state.?next.page.optMap(v, [v]),
        }.format_query()
      ).with({
        "Header":{
          "Authorization": ["Bearer " + state.api_token],
        },
      }).do_request().as(resp, resp.StatusCode == 200 ?
        bytes(resp.Body).decode_json().as(body, {
          "worklist": body,
          "index": 0,
        })
      :
        {
          "events": {
            "error": {
              "code": string(resp.StatusCode),
              "id": string(resp.Status),
              "message": "GET " + state.url.trim_right("/") + "/secure/vulnerability/v1/" + state.stage + "-results?" + (
                size(resp.Body) != 0 ?
                  string(resp.Body)
                :
                  string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
              ),
            },
          },
          "want_more": false,
        }
      )
  ).as(work,
    !has(work.worklist) ? state : // Exit early due to GET failure.
    work.index < size(work.worklist.data) ?
      request("GET",
        state.url.trim_right("/") + "/secure/vulnerability/v1/results/" + work.worklist.data[int(work.index)].resultId
      ).with({
        "Header":{
          "Authorization": ["Bearer " + state.api_token],
        },
      }).do_request().as(resp, resp.StatusCode == 200 ?
        bytes(resp.Body).decode_json().as(body, {
          "events":
            {
              // resolve baseImagesRef in layers
              "updated_layers":
              has(body.layers) ?
                body.layers.map(layer_id, {
                  "key": layer_id,
                  "value": body.layers[layer_id].with({
                    "baseImages": body.layers[layer_id].baseImagesRef.map(image_id,
                      body.baseImages[image_id].with({"baseImagesRef": image_id})
                    )
                  }).drop("baseImagesRef")
                }).as(result, zip(
                  result.map(e, e.key),
                  result.map(e, e.value)
                ))
              :
                {},
              // resolve riskAcceptRefs in vulnerabilities
              "updated_vulnerabilities": body.vulnerabilities.map(vulnerability_id, {
                "key": vulnerability_id,
                "value": body.vulnerabilities[vulnerability_id].with({
                  "riskAccepts": body.vulnerabilities[vulnerability_id].riskAcceptRefs != null ?
                    body.vulnerabilities[vulnerability_id].riskAcceptRefs.map(risk_id,
                      body.riskAccepts[risk_id].with({"riskAcceptRefs": risk_id})
                    )
                  :
                    []
                }).drop("riskAcceptRefs")
              }).as(result, zip(
                result.map(e, e.key),
                result.map(e, e.value)
              ))
            }.as(result, {
              // resolve vulnerabilitiesRefs and layerRef in package
              "updated_packages": body.packages.map(package_id, {
                "key": package_id,
                "value": body.packages[package_id].with({
                  ?"layers":  has(body.packages[package_id].layerRef) ?
                    optional.of(result.updated_layers[body.packages[package_id].layerRef].with({"layerRef":
                      body.packages[package_id].layerRef}))
                  :
                    optional.none(),
                  "vulnerability": body.packages[package_id].vulnerabilitiesRefs != null ?
                    body.packages[package_id].vulnerabilitiesRefs.map(vulnerability_id,
                      result.updated_vulnerabilities[vulnerability_id].with({"vulnerabilitiesRefs": vulnerability_id})
                    )
                  :
                    [{}],
                  "packageRef": package_id
                }).drop(["layerRef", "vulnerabilitiesRefs"])
              }).as(result, zip(
                result.map(e, e.key),
                result.map(e, e.value)
              ))
            }).as(result,
              // Create final object
              result.updated_packages.map(package_id,
                result.updated_packages[package_id].vulnerability.map(vuln_data, {
                  "message": {
                    "package" :
                      vuln_data != {} ?
                        result.updated_packages[package_id].with({"vulnerability": vuln_data})
                      :
                        result.updated_packages[package_id].with({"vulnerability": null}),
                    "assetType": body.assetType,
                    "metadata": body.metadata,
                    "producer": body.producer,
                    "stage": body.stage
                  }.with(work.worklist.data[int(work.index)]).encode_json()
                })
              )
            ).flatten().as(result,
              // handle the case when there is no package present
              size(result) == 0 ?
                [{
                  "message": {
                    "assetType": body.assetType,
                    "metadata": body.metadata,
                    "producer": body.producer,
                    "stage": body.stage
                  }.with(work.worklist.data[int(work.index)]).encode_json()
                }]
              :
                result
            ),
            "batch_size": state.batch_size,
            "api_token": state.api_token,
            "stage": state.stage,
            ?"worklist": int(work.index) + 1 < size(work.worklist.data) ? optional.of(work.worklist) : optional.none(),
            ?"index": int(work.index) + 1 < size(work.worklist.data) ? optional.of(int(work.index) + 1) : optional.none(),
            "want_more": int(work.index) + 1 < size(work.worklist.data) || has(work.worklist.page.next),
            "next": {
              ?"page": work.worklist.?page.next
            }
        })
      :
        {
          "events": {
            "error": {
              "code": string(resp.StatusCode),
              "id": string(resp.Status),
              "message": "GET " + state.url.trim_right("/") + "/secure/vulnerability/v1/results/" + work.worklist.data[int(work.index)].resultId + (
                size(resp.Body) != 0 ?
                  string(resp.Body)
                :
                  string(resp.Status) + ' (' + string(resp.StatusCode) + ')'
              ),
            },
          },
          "want_more": false,
          "next": {}
        }
      )
    :
      {
        "events": [],
        "want_more": false,
        "next": {}
      }
  )
tags:
{{#if preserve_original_event}}
  - preserve_original_event
{{/if}}
{{#if preserve_duplicate_custom_fields}}
  - preserve_duplicate_custom_fields
{{/if}}
{{#each tags as |tag|}}
  - {{tag}}
{{/each}}
{{#contains "forwarded" tags}}
publisher_pipeline.disable_host: true
{{/contains}}
{{#if processors}}
processors:
{{processors}}
{{/if}}
